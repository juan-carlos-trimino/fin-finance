package webfinances

import (
  //"encoding/json"
  "finance/middlewares"
  "finance/misc"
  "finance/sessions"
  "fmt"
  //The option -u instructs 'get' to update the module with dependencies.
  //go get -u github.com/google/uuid
  "github.com/google/uuid"
  //Package template (html/template) implements data-driven templates for generating HTML output
  //safe against code injection. It provides the same interface as text/template and should be used
  //instead of text/template whenever the output is HTML.
  "html/template"
  "net/http"
  "time"
)

var m = misc.Misc{}
var tmpl *template.Template

/***
In Go, the predefined init() function sets off a piece of code to run before any other part of the
package; i.e., adding the init() function tells the compiler that when the package is imported, it
should run the init() function once. Unlike the main() function that can only be declared once, the
init() function can be declared multiple times throughout a package.
***/
func init() {
  fmt.Printf("%s - Entering init/webfinances.\n", m.DTF())
  /***
  The Must function wraps around the ParseGlob function that returns a pointer to a template and an
  error, and it panics if the error is not nil.
  ***/
  tmpl = template.Must(template.ParseGlob("webfinances/templates/*.html"))
}

/***
When handling authentication errors, the application should not disclose which part of the
authentication data was incorrect. Instead of "Invalid username" or "Invalid password", just use
"Invalid username and/or password" interchangeably.
***/
func invalidSession(res http.ResponseWriter) {
  tmpl.ExecuteTemplate(res, "index_page", struct {
    Error string
  } { "Invalid username and/or password" })
}

func refresh(res http.ResponseWriter, req *http.Request) {
  // if !checkSession(res, req) {
  //   return
  // }
  cookie, _ := req.Cookie("session_token")
  //If the previous session is valid, create a new session token for the current user.
  sessionToken := uuid.NewString()
  expiresAt := time.Now().Add(120 * time.Second)
  sessions.Sessions[sessionToken] = sessions.Session{
    Username: sessions.Sessions[cookie.Value].Username,
    Expiry: expiresAt,
  }
  //Delete the old session token.
  delete(sessions.Sessions, cookie.Value)
  //Set the new token.
  http.SetCookie(res, &http.Cookie{
    Name: "session_token",
    Value: sessionToken,
    Expires: expiresAt,
  })
}

type WfPages struct{}

func (p WfPages) IndexPage(res http.ResponseWriter, req *http.Request) {
  fmt.Printf("%s - Entering IndexPage/webfinances.\n", m.DTF())
  tmpl.ExecuteTemplate(res, "index_page", nil)
}

func (p WfPages) LoginPage(res http.ResponseWriter, req *http.Request) {
  fmt.Printf("%s - Entering LoginPage/webfinances.\n", m.DTF())
  un := req.PostFormValue("username")
  pw := req.PostFormValue("password")
  //Get the expected password from the in memory map.
  password, ok := sessions.Users[un]
  if !ok {
    tmpl.ExecuteTemplate(res, "index_page", struct {
      Error string
    } {
        "Invalid username and/or password",
      })
    return
  } else if err := sessions.CompareHashAndPassword(password, []byte(pw)); err != nil {
    tmpl.ExecuteTemplate(res, "index_page", struct {
      Error string
    } {
        "Invalid username and/or password",
      })
    return
  }
  sessionToken := sessions.SetSessionToken(un)
  /***
  Once a cookie is set on a client, it is sent along with every subsequent request. Cookies store
  historical information (including user login information) on the client's computer. The client's
  browser sends these cookies everytime the user visits the same website, automatically completing
  the login step for the user.

  Sessions, on the other hand, store historical information on the server side. The server uses a
  session id to identify different sessions, and the session id that is generated by the server
  should always be random and unique. You can use cookies or URL arguments to get the client's
  identity.
  ***/
  http.SetCookie(res, &http.Cookie{
    Name: "session_token",
    Value: sessionToken,
    Expires: sessions.Sessions[sessionToken].Expiry,
  })
  //The browser redirects to the homepage after the server verifies the login information and
  //returns an HTTP response.
  http.Redirect(res, req, "/welcome", http.StatusSeeOther)
}

func (p WfPages) LogoutPage(res http.ResponseWriter, req *http.Request) {
  fmt.Printf("%s - Entering LogoutPage/webfinances.\n", m.DTF())
  cookie, err := req.Cookie("session_token")
  if err != nil {
    if err == http.ErrNoCookie {
      tmpl.ExecuteTemplate(res, "index_page", struct {
        Error string
      } {
          "Please loggin",
        })
    } else {
      tmpl.ExecuteTemplate(res, "index_page", struct {
        Error string
      } {
          "Bad request",
        })
    }
    return
  }
  delete(sessions.Sessions, cookie.Value)
  http.SetCookie(res, &http.Cookie{
    Name: "session_token",
    Value: "",
    Expires: time.Now(),
  })
  http.Redirect(res, req, "/", http.StatusSeeOther)
}

func (p WfPages) WelcomePage(res http.ResponseWriter, req *http.Request) {
  fmt.Printf("%s - Entering WelcomePage/webfinances.\n", m.DTF())
  ctxKey := middlewares.MwContextKey{}
  sessionStatus, _ := ctxKey.GetSessionStatus(req.Context())
  if sessionStatus {
    tmpl.ExecuteTemplate(res, "welcome_page", struct {
      Header string
      Datetime string
    } { "Investments", m.DTF() })
  } else {
    invalidSession(res)
  }
}

func (p WfPages) ContactPage(res http.ResponseWriter, req *http.Request) {
  fmt.Printf("%s - Entering ContactPage/webfinances.\n", m.DTF())
  ctxKey := middlewares.MwContextKey{}
  sessionStatus, _ := ctxKey.GetSessionStatus(req.Context())
  if sessionStatus {
    tmpl.ExecuteTemplate(res, "contact_page", struct {
      Header string
      Datetime string
    } { "Investments", m.DTF() })
  } else {
    invalidSession(res)
  }
}

func (p WfPages) AboutPage(res http.ResponseWriter, req *http.Request) {
  fmt.Printf("%s - Entering AboutPage/webfinances.\n", m.DTF())
  ctxKey := middlewares.MwContextKey{}
  sessionStatus, _ := ctxKey.GetSessionStatus(req.Context())
  if sessionStatus {
    /***
    Executing the template means that we take the content from the template files, combine it with
    data from another source, and generate the final HTML content.
    ***/
    tmpl.ExecuteTemplate(res, "about_page", struct {
      Header string
      Datetime string
    } { "Investments", m.DTF() })
  } else {
    invalidSession(res)
  }
}

func (p WfPages) PublicHomeFile(res http.ResponseWriter, req *http.Request) {
  fmt.Printf("%s - Entering PublicHomeFile/webfinances.\n", m.DTF())
  //if checkSession(res, req) {
  http.ServeFile(res, req, "./webfinances/public/css/home.css")
  //}
}

func (p WfPages) FinancesPage(res http.ResponseWriter, req *http.Request) {
  fmt.Printf("%s - Entering FinancesPage/webfinances.\n", m.DTF())
  ctxKey := middlewares.MwContextKey{}
  sessionStatus, _ := ctxKey.GetSessionStatus(req.Context())
  if sessionStatus {
    tmpl.ExecuteTemplate(res, "finances_page", struct {
      Header string
      Datetime string
    } { "Finances", m.DTF() })
  } else {
    invalidSession(res)
  }
}

func (p WfPages) SimpleInterestPage(res http.ResponseWriter, req *http.Request) {
  fmt.Printf("%s - Entering SimpleInterestPage/webfinances.\n", m.DTF())
  ctxKey := middlewares.MwContextKey{}
  sessionStatus, _ := ctxKey.GetSessionStatus(req.Context())
  if sessionStatus {
    tmpl.ExecuteTemplate(res, "simple_interest_page", struct {
      Header string
      Datetime string
    } { "Simple Interest", m.DTF() })
  } else {
    invalidSession(res)
  }
}

func (p WfPages) OrdinaryAnnuityPage(res http.ResponseWriter, req *http.Request) {
  fmt.Printf("%s - Entering OrdinaryAnnuityPage/webfinances.\n", m.DTF())
  ctxKey := middlewares.MwContextKey{}
  sessionStatus, _ := ctxKey.GetSessionStatus(req.Context())
  if sessionStatus {
    tmpl.ExecuteTemplate(res, "ordinary_annuity_page", struct {
      Header string
      Datetime string
    } { "Ordinary Annuity", m.DTF() })
  } else {
    invalidSession(res)
  }
}

func (p WfPages) AnnuityDuePage(res http.ResponseWriter, req *http.Request) {
  fmt.Printf("%s - Entering AnnuityDuePage/webfinances.\n", m.DTF())
  ctxKey := middlewares.MwContextKey{}
  sessionStatus, _ := ctxKey.GetSessionStatus(req.Context())
  if sessionStatus {
    tmpl.ExecuteTemplate(res, "annuity_due_page", struct {
      Header string
      Datetime string
    } { "Annuity Due", m.DTF() })
  } else {
    invalidSession(res)
  }
}


/*
https://astaxie.gitbooks.io/build-web-application-with-golang/content/en/06.2.html

//create a global session manager in the main() function
var globalSessions *session.Manager
//Initialize the session manager.
func init() {
  globalSessions = NewSessionManager("memory", "gosessionid", 3600)
}

-----------------
package sessionmanager

type SessionManager struct {
  cookieName string  //Private cookiename
  lock sync.Mutex  //Protect session
  provider Provider
  maxlifetime int64
}

func NewSessionManager(providerName, cookieName string, maxlifetime int64) *SessionManager, error) {
  provider, ok := provides[providerName]
  if !ok {
    return nil, fmt.Errorf(Session: unknown provider %q (forgotten import?), providerName)
  }
  return &SessionManager{ provider: provider, cookieName: cookieName, maxlifetime: maxlifetime }, nil
}
*/


