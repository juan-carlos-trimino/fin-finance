SELECT 'Output from script, run began at: ' AS "Script Information",
  NOW() AS "Date and Time Executed";

-- *******************
-- Create the database
-- *******************
-- Important - You should back up the master database each time that you create, modify, or drop a
-- database.
CREATE DATABASE db_banking_system
WITH
  ALLOW_CONNECTIONS = TRUE
  CONNECTION_LIMIT = -1  -- Unlimited connections.
  ENCODING = 'UTF8'
  LC_COLLATE = 'C.UTF8'  -- Determine the sort order of strings.
  LC_CTYPE = 'C.UTF8'  -- Define character classification rules.
  IS_TEMPLATE = FALSE  -- Only superusers or the database owner can clone the database.
  TEMPLATE = 'template0';

-- Connect to the database.
\c db_banking_system;

-- ******************
-- Create the schemas
-- ******************
CREATE SCHEMA IF NOT EXISTS bs;

-- Once connected, set the search path to look for objects in your schema first, and if not found,
-- to fall back to the default public schema.
SET search_path TO bs, public;

-- ************************************************************************************************
-- Create the tables
-- ************************************************************************************************
-- Customer - Account Relationship
-- One-to-Many Relationship - One customer is allowed to create many accounts.
-- Foreign Key - customer_id in tbl_account is referencing customer_id in tbl_customer.
-- Customer - Customer Info
-- One-to-One Relationship - One customer is allowed to create one customer information.
CREATE TABLE IF NOT EXISTS bs.tbl_customer(
  -- The id column is always generated by the system and users cannot explicitly insert values into
  -- it. See GENERATED BY DEFAULT AS IDENTITY.
  -- A primary key automatically enforces UNIQUE and NOT NULL constraints on the column(s) it's
  -- defined on.
  customer_id          INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  customer_type        VARCHAR(16)
                         CHECK(customer_type IN ('regular', 'premium'))
                         DEFAULT 'regular',
  username             VARCHAR(64) UNIQUE NOT NULL,
  password_hash        VARCHAR(256) NOT NULL,
  -- https://www.postgresql.org/docs/current/datatype-datetime.html
  -- This stores date and time along with time zone information. PostgreSQL automatically converts
  -- the timestamp to UTC for storage and adjusts it back based on the current time zone settings
  -- when queried.
  created_at           TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at           TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS bs.tbl_customer_info(
  customer_info_id  INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  -- Crucially, this foreign key column must also have a UNIQUE constraint applied to it. This
  -- UNIQUE constraint ensures that no two records in the child table (tbl_customer_info) can point
  -- to the same record in the parent table (tbl_customer), thus enforcing the "one-to-one" aspect.
  customer_id       INT UNIQUE NOT NULL,
  first_name        VARCHAR(64) NOT NULL,
  middle_name       VARCHAR(64),
  last_name         VARCHAR(64) NOT NULL,
  date_of_birth     DATE NOT NULL,  --YYYY-MM-DD
  tax_identifier    VARCHAR(16) NOT NULL,
  address_1         VARCHAR(128) NOT NULL,
  address_2         VARCHAR(128),
  city_name         VARCHAR(128) NOT NULL,
  state_name        VARCHAR(128) NOT NULL,
  country_name      VARCHAR(64) NOT NULL,
  zip_code          VARCHAR(16),
  primary_email     VARCHAR(256),
  secondary_email   VARCHAR(256),
  primary_phone     VARCHAR(16) NOT NULL,
  secondary_phone   VARCHAR(16),
  created_at        TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at        TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT fk_customer_info_to_customer
    FOREIGN KEY(customer_id)
    REFERENCES bs.tbl_customer(customer_id)
    -- Automatically deletes all the referencing rows in the child table (tbl_account) when the
    -- referenced rows in the parent table (tbl_customer) are deleted.
    ON DELETE CASCADE
);

-- Account - Transactions Relationship
-- Many-to-Many Relationship - An account can have multiple transactions and a transaction can
--                             involve multiple account numbers.
-- Foreign Key - account_id in tbl_transaction is referencing account_id in tbl_account.
CREATE TABLE IF NOT EXISTS bs.tbl_account(
  account_id      INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  customer_id     INT NOT NULL,
  account_number  VARCHAR(32) NOT NULL,
  account_type    VARCHAR(16)
                    CHECK(account_type IN ('savings', 'checking'))
                    DEFAULT 'checking',
  account_status  VARCHAR(16),
                    CHECK(account_status IN ('active', 'closed', 'suspended')),
  balance         NUMERIC(12, 2) NOT NULL,  -- $9,999,999,999.99
  created_at1     DATE NOT NULL,
  closed_at       DATE,
  created_at      TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at      TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT fk_account_to_customer
    FOREIGN KEY(customer_id)
    REFERENCES bs.tbl_customer(customer_id)
    -- Automatically deletes all the referencing rows in the child table (tbl_account) when the
    -- referenced rows in the parent table (tbl_customer) are deleted.
    ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS bs.tbl_transactions(
  transaction_id    INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  account_id        INT NOT NULL,
  transaction_type  VARCHAR(16) NOT NULL
                      CHECK(transaction_type IN ('deposit', 'withdrawal')),
  transaction_date  TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  amount            NUMERIC(12, 2) NOT NULL CHECK(amount > 0),
  -- occurance         TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  created_at        TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at        TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT fk_transactions_to_account
    FOREIGN KEY(account_id)
    REFERENCES bs.tbl_account(account_id)
    ON DELETE CASCADE
);

/**************************************************************************************************
Create the stored procedures
***************************************************************************************************
This statement will create the procedure if it doesn't exist, or replace its definition if it does.
This is a more concise way to update or create a procedure.
**************************************************************************************************/
CREATE OR REPLACE PROCEDURE bs.sp_customer(
 IN pusername VARCHAR(64),
 IN ppassword_hash VARCHAR(256),
 IN pcustomer_type VARCHAR(16) DEFAULT 'regular',
 INOUT pcustomer_id INT DEFAULT -1)
 /***
 In PostgreSQL, when discussing "procedure language SQL vs PostgreSQL," the distinction lies in
 the type of functions or procedures you can create within the database.
 When to choose which:
  * Use LANGUAGE SQL when your function primarily involves data manipulation or retrieval that can
    be expressed efficiently through SQL statements, and complex procedural logic is not required.
  * Use LANGUAGE PL/pgSQL when you need advanced procedural capabilities, such as loops,
    conditional logic, error handling, or dynamic SQL generation, that are not possible or
    practical with pure SQL functions.
 ***/
LANGUAGE PLPGSQL
/***
This defines the procedure's body using dollar-quoted string constants. This avoids the need to
escape single quotes within the procedure's code.
***/
AS $$
  /***
  (Optional) This section within the procedure body is used to declare local variables that are
  only accessible within the procedure.
  ***/
  -- DECLARE
  /***
  This block encloses the SQL statements and control structures that constitute the procedure's
  logic.
  ***/
BEGIN
  INSERT INTO bs.tbl_customer(customer_type, username, password_hash)
   VALUES(pcustomer_type, pusername, ppassword_hash)
   RETURNING customer_id INTO pcustomer_id;
END;
/***
The final semicolon marks the end of the CREATE PROCEDURE statement.
***/
$$;





CREATE OR REPLACE PROCEDURE bs.sp_customer_info(
  IN username VARCHAR(64),
  IN password_hash VARCHAR(256),
  IN customer_type VARCHAR(16),
  IN first_name VARCHAR(64),
  IN middle_name VARCHAR(64),
  IN last_name VARCHAR(64),
  IN date_of_birth DATE,
  IN tax_identifier VARCHAR(16),
  IN address_1 VARCHAR(128),
  IN address_2 VARCHAR(128),
  IN city_name VARCHAR(128),
  IN state_name VARCHAR(128),
  IN country_name VARCHAR(64),
  IN zip_code VARCHAR(16),
  IN primary_email VARCHAR(256),
  IN secondary_email VARCHAR(256),
  IN primary_phone VARCHAR(16),
  IN secondary_phone VARCHAR(16)
)
LANGUAGE PLPGSQL
AS $$
DECLARE
 customer_id INT = -1;
BEGIN
  CALL bs.sp_customer(username, password_hash, customer_type, customer_id);
  INSERT INTO bs.tbl_customer_info (customer_id, first_name, middle_name, last_name, date_of_birth, tax_identifier,
   address_1, address_2, city_name, state_name, country_name, zip_code, primary_email,
   secondary_email, primary_phone, secondary_phone)
   VALUES(customer_id, first_name, middle_name, last_name, date_of_birth, tax_identifier, address_1, address_2,
    city_name, state_name, country_name, zip_code, primary_email, secondary_email, primary_phone,
    secondary_phone);
  COMMIT;
END;
$$;



SELECT 'Output from script, run ended at: ' AS "Script Information",
  NOW() AS "Date and Time Executed";
